{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 First and foremost at the beginning of any project there is both a combination of fear and miscalculation. I think for any computer programmer about the embark on an engineering journey of which they are unfamiliar, there is a fear that the task at hand and the many twist and turns and journey is bound to produce will be insurmountable for our budding skills. Fear is often apprehension of the unknown, which leads to the later point about the beginning of every project\'97miscalculation. It has rarely, if ever, been the case that a project has taken less time than I thought it would take to complete, even with conservative approximations. It seems, that not matter what I do, projects will take at least three times as long as I have budgeted for. \
\
Every journey begins with a single step. I wasn\'92t entirely sure how to begin projectNeon. I had been mulling over in my mind some elements that I would need and would have to account for, but that\'92s a far leap from putting something down on paper (or in this case in my Processing IDE). I thought a good place to start is with what I know. Just create a canvas, and make it black. Done. Off to a great start. Now, lets get some objects on this blank screen, might as well put up one of the awesome graphics my project partner Dante drew up. And, that\'92s when I encountered the first problem. None of the graphics were saved as SVGs. Trying to export and upload a simple SVG was throwing errors.\
\
Found that the PShape method provided by processing couldn\'92t process the vector graphic I wanted to use, so instead used another graphic rendering library called geomerative. \
\
I was going to hand code the physics engines for the objects, since I had learned the algorithms in a P5.js course on Kadenze with Andrew Shiffman, and then just convert what I created in javascript to Java. However, while searching for the geomerative library I stumbled upon the AI for 2D Games library, which possessed the same steering behaviors I was going to be using. I decided to read the documentation for the library and try to use it instead of converting my the algorithms I had developed in javascript to Java. \
\
Starting to understand the library, however I need to figure out how to render the SVGs I have created through the game2Dai library, or get the geomerative library to work with the game2Dai library. It\'92s not entirely evident how to do so from the library. They provide a method for bitmaps, but I don\'92t see anything specifically mentioned about rendering SVG graphics.\
\
After looking through a number of examples provided by the library, I found one similar enough to what I was trying to do, and experimented a little bit to find a way to use geomerative and game2Dai together to alter the appearance of the vehicle to be the SVG created for the player\'92s ship. I then had to adjust the collision radius and angle of the graphic to match the heading of the vehicle.\
\
December 4 (Build Day):\
Today the team is getting together to wire the hardware, and get the software to interact with the hardware. Jason was able to construct an arcade controller with a joystick and two buttons. Dante acquired some led strip lights that we would also like to implement in the controller. The entirety of the game has not been programmed yet, but since today\'92s goal is to get the software and hardware working together, that will be my focus. \
\
Instead of using serial communication between the arduino the processing software we are using for the game, we are going to use Firmata, which is \'93a protocol for communicating with micro controllers from software on a host computer.\'94 I prefer using Firmata because it gives me control over the micro controller all from my processing sketch, keeping all of my code in the same place. Laziness is the key to progress.\
\
i was able to get Firmata loaded without much trouble, and tested the communication with a simple blinking led. However, I noticed the motion of the game became choppy because it needed to wait for the whole led blinking protocol which incorporates delays to complete before it could run the movement of the game. Since this functionality isn\'92t part of the overall program, I will ignore.\
\
Now the software and micro controller are ready to connect to the sensors (the buttons and joystick). Looking at some of the documentation, I\'92m seeing that I will likely need to incorporate some sort debouncing software to account for the vibration and \'93noise\'94 created from the press of a button. Also, since the joystick we are using has digital outputs instead of analog, I will need to figure out how that will impact calculating the direction of the ship.\
\
The digital output vs. analog output nature of the joystick we purchased has created a major snag in the software development process. The method/library I was using to steer the ship will now only apply to the auto objects floating in space. Since we won\'92t be able to use the joystick to produce an angle for the ship to travel in, we will have to use the joystick to simply rotate the ship. This is a little disappointing to me, since it essentially only uses the left and right directions of the joystick. The reason this has become a major snag is because I didn\'92t understand vectors and Processing\'92s use of vectors PVector as well as I would like. \
\
December 5\
I have been able to get the software to work, and Dante has wired the arcade controller peripherals to the microcontroller. While the arduino seems to be communicating with processing and reading the inputs, I\'92m having difficulty getting the state to change when the switch is activated. Since the switches on the buttons and joystick are have both Normally Open (NO) and Normally Closed (NC) contacts, I\'92m thinking I have to use arduino\'92s INPUT_PULLUP function available in the firmware. Unfortunately, it doesn\'92t appear that Firmata has a function capable of setting a pin to a PULLUP mode. Pull-up resistors, which are built into the micro-controllers, hold a pin in a steady HIGH state, compared to a \'93floating\'94 state, which would be unpredictably either HIGH or LOW since the pin wasn\'92t connected to anything. I\'92ve had pins read both HIGH and LOW, but have never been able to get them to change state, so I might just have to program the pins and buttons in the arduino IDE, and ditch Firmata. {\field{\*\fldinst{HYPERLINK "http://www.cuddleburrito.com/blog/2015/3/17/arduino-arcade-joystick-controller"}}{\fldrslt http://www.cuddleburrito.com/blog/2015/3/17/arduino-arcade-joystick-controller}}\
\
Decided to opt for the emulator, however, the Arduino firmware isn\'92t set up to act as a HID like the Leonardo, meaning it isn\'92t able to operate as a keyboard. There is a firmware upgrade available for the UNO to make it HID compatible, but it would require a complete reset of the device and a jumper to bridge the reset pin with the ground. I don\'92t have a jumper, but fortunately Dante has an Arduino Leonardo, so we switched to programming on his microcontroller instead.\
\
The Leonardo works, and the firmware comes with a Keyboard library that allows me to assign pins to keyboard commands, so it\'92s like connecting a USB keyboard. What\'92s nice about this is I assumed I would have to send character strokes from the arcade pad over a serial communication, but since the computer reads the arcade pad as a keyboard, no serial communication is necessary between the arduino sketch and processing.}